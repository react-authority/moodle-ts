#!/usr/bin/env node
/**
 * Code Generation Script for moodle-ts
 *
 * Generates TypeScript types and typed function wrappers from Moodle schema JSON files.
 *
 * Usage:
 *   node scripts/codegen.mjs [schemaFile]
 *
 * If no schema file is provided, processes all JSON files in the schemas/ directory.
 */

import { readFileSync, writeFileSync, readdirSync, existsSync, mkdirSync } from "fs";
import { join, basename, dirname } from "path";
import { fileURLToPath } from "url";

const __dirname = dirname(fileURLToPath(import.meta.url));
const ROOT_DIR = join(__dirname, "..");
const SCHEMAS_DIR = join(ROOT_DIR, "schemas");
const GENERATED_DIR = join(ROOT_DIR, "src", "generated");

/**
 * Convert a Moodle schema type to TypeScript type
 */
function schemaTypeToTS(schema, indent = 0) {
  if (!schema) {
    return "unknown";
  }

  const padding = "  ".repeat(indent);

  switch (schema.type) {
    case "integer":
      return "number";
    case "number":
      return "number";
    case "boolean":
      return "boolean";
    case "string":
      return "string";
    case "array": {
      const itemType = schema.items ? schemaTypeToTS(schema.items, indent) : "unknown";
      return `${itemType}[]`;
    }
    case "object": {
      if (!schema.properties || Object.keys(schema.properties).length === 0) {
        return "Record<string, unknown>";
      }
      const requiredFields = new Set(schema.required || []);
      const props = Object.entries(schema.properties)
        .map(([key, value]) => {
          const optional = !requiredFields.has(key) && value.required !== true ? "?" : "";
          const propType = schemaTypeToTS(value, indent + 1);
          const description = value.description
            ? `${padding}  /** ${escapeComment(value.description)} */\n`
            : "";
          const safeName = isValidIdentifier(key) ? key : `"${key}"`;
          return `${description}${padding}  ${safeName}${optional}: ${propType};`;
        })
        .join("\n");
      return `{\n${props}\n${padding}}`;
    }
    default:
      return "unknown";
  }
}

/**
 * Check if a string is a valid JS identifier
 */
function isValidIdentifier(name) {
  return /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(name);
}

/**
 * Escape comment content
 */
function escapeComment(str) {
  return str.replace(/\*\//g, "*\\/").replace(/\n/g, " ");
}

/**
 * Convert function name to PascalCase for type names
 */
function toPascalCase(str) {
  return str
    .split("_")
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join("");
}

/**
 * Generate TypeScript code for a single function
 */
function generateFunction(func) {
  const typeName = toPascalCase(func.name);
  const paramsTypeName = `${typeName}Params`;
  const returnsTypeName = `${typeName}Returns`;

  let code = "";

  // Generate description comment
  if (func.description) {
    code += `/**\n * ${escapeComment(func.description)}\n`;
    if (func.capabilities) {
      code += ` * @capabilities ${func.capabilities}\n`;
    }
    code += ` */\n`;
  }

  // Generate params type
  const paramsType = schemaTypeToTS(func.parameters, 0);
  code += `export type ${paramsTypeName} = ${paramsType};\n\n`;

  // Generate returns type
  if (func.returns) {
    const returnsType = schemaTypeToTS(func.returns, 0);
    code += `export type ${returnsTypeName} = ${returnsType};\n\n`;
  } else {
    code += `export type ${returnsTypeName} = null;\n\n`;
  }

  return {
    typeName,
    paramsTypeName,
    returnsTypeName,
    code,
    name: func.name,
    description: func.description,
  };
}

/**
 * Generate the functions.ts file with typed function creators
 */
function generateFunctionsFile(functions, moodleVersion) {
  let code = `/**
 * Auto-generated typed function wrappers for Moodle ${moodleVersion}
 * Generated at: ${new Date().toISOString()}
 * 
 * DO NOT EDIT - This file is generated by scripts/codegen.mjs
 */

import type { MoodleClient, CallResult } from "../../client/index.js";
import type * as Types from "./types.js";

`;

  for (const func of functions) {
    const { name, typeName, paramsTypeName, returnsTypeName, description } = func;

    code += `/**\n`;
    if (description) {
      code += ` * ${escapeComment(description)}\n`;
    }
    code += ` * @see https://docs.moodle.org/dev/${name}\n`;
    code += ` */\n`;
    code += `export async function ${name}(\n`;
    code += `  client: MoodleClient,\n`;
    code += `  params: Types.${paramsTypeName}\n`;
    code += `): Promise<CallResult<Types.${returnsTypeName}>> {\n`;
    code += `  return client.call<Types.${paramsTypeName}, Types.${returnsTypeName}>("${name}", params);\n`;
    code += `}\n\n`;
  }

  return code;
}

/**
 * Generate index.ts that re-exports everything
 */
function generateIndexFile(moodleVersion, moodleRelease) {
  return `/**
 * Auto-generated exports for Moodle ${moodleVersion}
 * Moodle Release: ${moodleRelease}
 * Generated at: ${new Date().toISOString()}
 * 
 * DO NOT EDIT - This file is generated by scripts/codegen.mjs
 */

export * from "./types.js";
export * from "./functions.js";
`;
}

/**
 * Process a single schema file and generate TypeScript code
 */
function processSchema(schemaPath) {
  const schemaName = basename(schemaPath, ".json");
  console.log(`Processing schema: ${schemaName}`);

  const schemaContent = readFileSync(schemaPath, "utf-8");
  const schema = JSON.parse(schemaContent);

  const outputDir = join(GENERATED_DIR, schemaName);
  if (!existsSync(outputDir)) {
    mkdirSync(outputDir, { recursive: true });
  }

  // Generate types
  let typesCode = `/**
 * Auto-generated types for Moodle ${schema.moodleVersion || schemaName}
 * Moodle Release: ${schema.moodleRelease || "unknown"}
 * Generated at: ${new Date().toISOString()}
 * 
 * DO NOT EDIT - This file is generated by scripts/codegen.mjs
 */

`;

  const generatedFunctions = [];

  for (const func of schema.functions || []) {
    const generated = generateFunction(func);
    typesCode += generated.code;
    generatedFunctions.push(generated);
  }

  writeFileSync(join(outputDir, "types.ts"), typesCode);
  console.log(`  Generated types.ts with ${generatedFunctions.length} types`);

  // Generate functions
  const functionsCode = generateFunctionsFile(
    generatedFunctions,
    schema.moodleVersion || schemaName
  );
  writeFileSync(join(outputDir, "functions.ts"), functionsCode);
  console.log(`  Generated functions.ts`);

  // Generate index
  const indexCode = generateIndexFile(
    schema.moodleVersion || schemaName,
    schema.moodleRelease || "unknown"
  );
  writeFileSync(join(outputDir, "index.ts"), indexCode);
  console.log(`  Generated index.ts`);

  return schemaName;
}

/**
 * Update package.json exports with generated versions
 */
function updatePackageExports(versions) {
  const packagePath = join(ROOT_DIR, "package.json");
  const packageJson = JSON.parse(readFileSync(packagePath, "utf-8"));

  // Keep the root export
  const exports = {
    ".": packageJson.exports["."],
  };

  // Add exports for each generated version
  for (const version of versions) {
    exports[`./moodle/${version}`] = {
      types: `./dist/generated/${version}/index.d.ts`,
      import: `./dist/generated/${version}/index.js`,
    };
  }

  packageJson.exports = exports;
  writeFileSync(packagePath, JSON.stringify(packageJson, null, 2) + "\n");
  console.log(`\nUpdated package.json exports with ${versions.length} versions`);
}

/**
 * Main entry point
 */
function main() {
  const args = process.argv.slice(2);

  // Ensure output directory exists
  if (!existsSync(GENERATED_DIR)) {
    mkdirSync(GENERATED_DIR, { recursive: true });
  }

  let schemaFiles = [];

  if (args.length > 0) {
    // Process specific schema files
    schemaFiles = args.map((arg) => {
      if (arg.endsWith(".json")) {
        return arg;
      }
      return join(SCHEMAS_DIR, `${arg}.json`);
    });
  } else {
    // Process all schemas in the schemas directory
    if (!existsSync(SCHEMAS_DIR)) {
      console.log("No schemas directory found. Creating placeholder...");
      mkdirSync(SCHEMAS_DIR, { recursive: true });
      console.log("Run extract-ws.php in a Moodle installation to generate schemas.");
      return;
    }

    schemaFiles = readdirSync(SCHEMAS_DIR)
      .filter((f) => f.endsWith(".json"))
      .map((f) => join(SCHEMAS_DIR, f));
  }

  if (schemaFiles.length === 0) {
    console.log("No schema files found.");
    console.log("Place Moodle schema JSON files in the schemas/ directory.");
    return;
  }

  const processedVersions = [];
  for (const schemaFile of schemaFiles) {
    if (!existsSync(schemaFile)) {
      console.error(`Schema file not found: ${schemaFile}`);
      continue;
    }
    const version = processSchema(schemaFile);
    processedVersions.push(version);
  }

  if (processedVersions.length > 0) {
    updatePackageExports(processedVersions);
  }

  console.log("\nCode generation complete!");
}

main();
